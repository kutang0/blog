---
layout: post
title: I2C Arbitration
subtitle: I2C arbitration is simple
tags: [I2C]
---

I2C는 멀티마스터를 지원한다. 근데 그게 그렇게 어려운 기능인가? 여기서는 여러 마스터가 어떻게 다른 마스터와의 충돌을 피하는지 짧게 정리한다.

통신에서 마스터와 슬레이브를 정의하자. 마스터는 전송을 요청할 수 있는 능동적인 녀석이고 슬레이브는 요청을 받는 놈이다. (그렇게 따지면 서버/클라이언트 정의와 그 정의가 배타적이지는 않은 것 같다.) 그 요청이 쓰기요청이면 슬레이브는 방금 마스터로부터 받은 데이터를 잘 받고 끝이다. 요청이 읽기요청이면 슬레이브는 데이터를 다시 마스터로 전송하여 결과적으로 마스터가 원하는 데이터를 취득하게한다.

멀티마스터를 사용할 때는 추가적인 약속이 필요하다. 보낼 수 있는 데이터 통로는 하나이기 때문에(SDA) 그 통로를 점유하기 위한 프로토콜이 필요하다. 그렇지 않으면 마스터들이 서로 자기 말만 하고 직렬통신의 특성상 그렇게 섞인 데이터까지 다시 해석할 여러운 방법을 선택할 개발자가 있는지는 모르겠다. 

우리에게 마스터1와 마스터2가 있다고 하자. 마스터1이 데이터를 보내는 중이었다면 SCL신호를 보면된다. 슬레이브가 보내든 마스터가 보내든 데이터를 보내는 놈은 클락신호까지 함께 보낼 책임이 있다.

그럼 중재는 언제 필요한가? 마스터1과 마스터2가 동시에 데이터를 보내기 시작할 때이다. 마스터1이 보낼 데이터가 0001이고 마스터2가 보낼 데이터가 0011이라고 하면 마스터1와 마스터2는 두번째 0을 보낼때까지는 서로 같은 데이터를 보내기 때문에 충돌이 일어나지 않는다. 중재프로토콜의 효과가 발생할 때는 마스터1이 0을 보내고 마스터2가 1을 보내는 시점이다. I2C 스펙상 이럴 때 0을 가지는 마스터1이 버스를 점유하고 마스터2는 자기가 보낸 데이터가 그대로 버스에서 보이지 않기 때문에 버스점유를 포기한다. 근데 왜 이렇게 0을 가지는 놈이 이기게 해놨을까?

SCL을 연결할 때 풀업을 시킨다. 그리고 Open Collector와 같이 사용하게 되면 회로자체가 AND 게이트처럼 동작하게 된다. [Wired Logic Connection](https://en.wikipedia.org/wiki/Wired_logic_connection) 마스터1이 0을 보내고 마스터2가 1을 보낼 때 SCL의 전압은 0으로 유지가 된다. 회로수준에서 발생하는 일이고, 따라서 마스터2가 SCL을 다시 읽어 내가 보낸 값이랑 다르다는 사실만 확인하면 된다.

